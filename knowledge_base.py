Knowledges = [
    {
        "input": "什么是数据结构？",
        "output": "数据结构是某一数据对象的所有数据成员之间的关系,记为:Data_Structure={D,S}。其中,D是某一数据对象,即数据元素的有限集合,S是该对象中所有数据成员之间的关系的有限集合。",
        "label": ["定义", "数据对象", "数据成员关系"]
    },
    {
        "input": "数据结构包含哪些方面的内容？",
        "output": "数据结构包含三方面的内容：数据结构，存储结构和和数据的运算。",
        "label": ["数据结构", "存储结构", "数据运算"]
    },
    {
        "input": "请简要介绍数据结构相关的知识内容。",
        "output": "数据结构是描述数据元素之间关系的抽象模型，关注数据元素之间的逻辑关系，通常分为以下四种基本类型：集合结构、线性结构、树形结构和图形结构。",
        "label": ["数据结构", "存储结构", "数据运算"]
    },
    {
        "input": "数据结构的存储结构包含哪些类型？",
        "output": "存储结构是数据的数据结构在计算机中的物理实现方式，主要包括顺序存储、链式存储、索引存储和散列存储四种类型‌。",
        "label": ["物理实现", "存储类型", "四种类型"]
    },
    {
        "input": "数据运算在数据结构中的作用是什么？",
        "output": "数据运算是定义在数据结构上的一组操作集合，包括插入、删除、搜索、排序等基本操作，这些操作直接影响算法的执行效率‌。",
        "label": ["操作集合", "基本操作", "执行效率"]
    },
    {
        "input": "数据结构与算法有何关联？",
        "output": "数据结构为算法提供数据组织基础，精心选择的数据结构可产生高效率的算法，两者共同构成解决特定问题的完整方案‌。",
        "label": ["数据组织", "高效率算法", "完整方案"]
    },
    {
        "input": "数据对象和数据元素有何区别？",
        "output": "数据对象是性质相同的数据元素集合，而数据元素是数据的基本单位，由若干数据项组成。例如大写字母集合是数据对象，单个字母'A'是数据元素。",
        "label": ["数据对象", "数据元素", "区别"]
    },
    {
        "input": "什么是抽象数据类型(ADT)?",
        "output": "抽象数据类型是数据结构的数学模型,通过操作接口描述数据数据结构和相关运算,与物理实现分离。例如栈的ADT定义入栈(push)、出栈(pop)等操作‌。",
        "label": ["数学模型", "操作接口", "物理实现分离"]
    },
    {
        "input": "如何评价数据结构的选择优劣？",
        "output": "评价标准包括：存储空间利用率、操作实现复杂度、算法时间/空间效率，需结合具体应用场景进行综合考量‌。",
        "label": ["评价标准", "综合考量", "应用场景"]
    },
    {
        "input": "线性表的基本定义是什么？",
        "output": "线性表是具有相同数据类型元素的有限序列，元素间呈线性逻辑关系，可通过顺序存储（数组）或链式存储（链表）实现。",
        "label": ["有限序列", "线性逻辑关系", "存储实现"]
    },
    {
        "input": "链表的核心特点有哪些？",
        "output": "链表通过指针域实现动态存储分配,分为单链表(单向遍历)、双向链表(双向遍历)和循环链表(首尾相连)三种类型,支持O(1)时间复杂度的插入/删除操作‌。",
        "label": ["动态存储", "三种类型", "时间复杂度"]
    },
    {
        "input": "栈的主要操作规则是什么？",
        "output": "栈遵循后进先出(LIFO)原则,核心操作包括push(入栈)、pop(出栈)和peek(查看栈顶元素)，常用于函数调用栈、表达式求值等场景。",
        "label": ["LIFO", "核心操作", "应用场景"]
    },
    {
        "input": "队列的典型应用场景有哪些？",
        "output": "队列遵循先进先出(FIFO)原则,基础操作含enqueue(入队)和dequeue(出队）,广泛应用于任务调度、打印缓冲及广度优先搜索算法。",
        "label": ["FIFO", "基础操作", "应用场景"]
    },
    {
        "input": "树结构的基本组成部分是什么？",
        "output": "树由节点和边构成,包含根节点、父节点、子节点和叶节点,二叉树、二叉搜索树和平衡树(如AVL树)是其重要衍生结构，用于层次化数据组织。",
        "label": ["节点和边", "衍生结构", "数据组织"]
    },
    {
        "input": "优先级队列的实现原理是什么？",
        "output": "优先级队列基于堆结构实现，支持按优先级动态获取元素，最大堆保证父节点值≥子节点，最小堆则相反，常用于任务调度系统。",
        "label": ["堆结构", "优先级", "任务调度"]
    },
    {
        "input": "集合结构的核心特性是什么？",
        "output": "集合存储互异元素且无序,支持并集、交集和差集运,哈希表是实现高效集合操作(O(1)时间复杂度)的典型存储结构。",
        "label": ["互异元素", "无序", "哈希表"]
    },
    {
        "input": "静态查找表的实现方法有哪些？",
        "output": "静态查找表包含顺序查找(O(n))和二分查找(O(log n))，后者要求数据有序且采用顺序存储，适用于低频更新、高频查询场景‌。",
        "label": ["顺序查找", "二分查找", "适用场景"]
    },
    {
        "input": "常见排序算法如何分类？",
        "output": "排序算法分比较类(快速排序O(n log n)、冒泡排序O(n²))和非比较类(计数排序O(n+k))，稳定性与时间复杂度是评价关键指标。",
        "label": ["比较类", "非比较类", "评价指标"]
    },
    {
        "input": "图结构的主要存储方式有哪些？",
        "output": "图的存储方式包括邻接矩阵(空间O(n²)，适合稠密图)和邻接表(空间O(n+e)，适合稀疏图)，前者支持快速判连，后者节省空间‌。",
        "label": ["邻接矩阵", "邻接表", "适用场景"]
    },
    {
        "input": "分治法的核心思想是什么？",
        "output": "分治法将问题分解为若干子问题递归求解后合并结果,如归并排序和快速排序,时间复杂度通常为O(n log n)。",
        "label": ["问题分解", "递归求解", "合并结果"]
    },
    {
        "input": "动态规划算法的适用条件有哪些？",
        "output": "动态规划要求问题具备最优子结构和重叠子问题特性，通过状态转移方程和记忆化存储（如背包问题）实现高效求解。",
        "label": ["最优子结构", "重叠子问题", "高效求解"]
    },
    {
        "input": "队列与栈的本质区别是什么？",
        "output": "队列遵循先进先出(FIFO)原则,栈遵循后进先出(LIFO)原则,二者操作受限的线性结构特性决定其应用场景差异‌。",
        "label": ["FIFO", "LIFO", "应用场景差异"]
    },
    {
        "input": "哈希表如何处理冲突？",
        "output": "冲突处理方法包含开放地址法（线性探测、二次探测）和链地址法，前者通过探测新存储位置，后者在冲突位置建立链表存储。",
        "label": ["开放地址法", "链地址法", "冲突处理"]
    },
    {
        "input": "B树与B+树的核心差异是什么？",
        "output": "B树所有节点存储数据,B+树仅叶节点存数据且含顺序访问指针，后者更适用于数据库索引等磁盘密集型查询场景。",
        "label": ["节点存储", "顺序访问指针", "适用场景"]
    },
    {
        "input": "迪杰斯特拉算法的适用条件？",
        "output": "要求图结构无负权边,采用贪心策略求解单源最短路径问题,时间复杂度为O(n²),可通过优先队列优化至O(m + n log n)。",
        "label": ["无负权边", "贪心策略", "时间复杂度"]
    }
]
# Knowledges = [
#     {
#     "input": "什么是数据结构？",
#     "output": "数据结构是某一数据对象的所有数据成员之间的关系,记为:Data_Structure={D,S}。其中,D是某一数据对象,即数据元素的有限集合,S是该对象中所有数据成员之间的关系的有限集合。"
#     },
#     {
#     "input": "数据结构包含哪些方面的内容？",
#     "output": "数据结构包含三方面的内容：数据结构，存储结构和和数据的运算。"
#     },
#     {
#     "input": "请简要介绍数据结构相关的知识内容。",
#     "output": "数据结构是描述数据元素之间关系的抽象模型，关注数据元素之间的逻辑关系，通常分为以下四种基本类型：集合结构、线性结构、树形结构和图形结构。"
#     },
#     { 
#     "input": "数据结构的存储结构包含哪些类型？",
#     "output": "存储结构是数据的数据结构在计算机中的物理实现方式，主要包括顺序存储、链式存储、索引存储和散列存储四种类型‌。"
#     }, 
#     { 
#     "input": "数据运算在数据结构中的作用是什么？",
#     "output": "数据运算是定义在数据结构上的一组操作集合，包括插入、删除、搜索、排序等基本操作，这些操作直接影响算法的执行效率‌。"
#     }, 
#     { 
#     "input": "数据结构与算法有何关联？",
#     "output": "数据结构为算法提供数据组织基础，精心选择的数据结构可产生高效率的算法，两者共同构成解决特定问题的完整方案‌。"
#     }, 
#     { 
#     "input": "数据对象和数据元素有何区别？",
#     "output": "数据对象是性质相同的数据元素集合，而数据元素是数据的基本单位，由若干数据项组成。例如大写字母集合是数据对象，单个字母'A'是数据元素。" 
#     },
#     { 
#     "input": "什么是抽象数据类型(ADT)?",
#     "output": "抽象数据类型是数据结构的数学模型,通过操作接口描述数据数据结构和相关运算,与物理实现分离。例如栈的ADT定义入栈(push)、出栈(pop)等操作‌。"
#     }, 
#     {
#     "input": "如何评价数据结构的选择优劣？", 
#     "output": "评价标准包括：存储空间利用率、操作实现复杂度、算法时间/空间效率，需结合具体应用场景进行综合考量‌。"
#     },
#     {
#     "input": "线性表的基本定义是什么？",
#     "output": "线性表是具有相同数据类型元素的有限序列，元素间呈线性逻辑关系，可通过顺序存储（数组）或链式存储（链表）实现。" 
#     },
#     {
#     "input": "链表的核心特点有哪些？",
#     "output": "链表通过指针域实现动态存储分配,分为单链表(单向遍历)、双向链表(双向遍历)和循环链表(首尾相连)三种类型,支持O(1)时间复杂度的插入/删除操作‌。 " 
#     },
#     {
#     "input": "栈的主要操作规则是什么？",
#     "output": "栈遵循后进先出(LIFO)原则,核心操作包括push(入栈)、pop(出栈)和peek(查看栈顶元素)，常用于函数调用栈、表达式求值等场景。" 
#     },
#     {
#     "input": "队列的典型应用场景有哪些？",
#     "output": "队列遵循先进先出(FIFO)原则,基础操作含enqueue(入队)和dequeue(出队）,广泛应用于任务调度、打印缓冲及广度优先搜索算法。" 
#     },
#     {
#     "input": "树结构的基本组成部分是什么？",
#     "output": "树由节点和边构成,包含根节点、父节点、子节点和叶节点,二叉树、二叉搜索树和平衡树(如AVL树)是其重要衍生结构，用于层次化数据组织。" 
#     },
#     {
#     "input": "优先级队列的实现原理是什么？",
#     "output": "优先级队列基于堆结构实现，支持按优先级动态获取元素，最大堆保证父节点值≥子节点，最小堆则相反，常用于任务调度系统。" 
#     },
#     {
#     "input": "集合结构的核心特性是什么？",
#     "output": "集合存储互异元素且无序,支持并集、交集和差集运,哈希表是实现高效集合操作(O(1)时间复杂度)的典型存储结构。" 
#     },
#     {
#     "input": "静态查找表的实现方法有哪些？",
#     "output": "静态查找表包含顺序查找(O(n))和二分查找(O(log n))，后者要求数据有序且采用顺序存储，适用于低频更新、高频查询场景‌。" 
#     },
#     {
#     "input": "常见排序算法如何分类？",
#     "output": "排序算法分比较类(快速排序O(n log n)、冒泡排序O(n²))和非比较类(计数排序O(n+k))，稳定性与时间复杂度是评价关键指标。" 
#     },
#     {
#     "input": "图结构的主要存储方式有哪些？",
#     "output": "图的存储方式包括邻接矩阵(空间O(n²)，适合稠密图)和邻接表(空间O(n+e)，适合稀疏图)，前者支持快速判连，后者节省空间‌。" 
#     },
#     {
#     "input": "分治法的核心思想是什么？",
#     "output": "分治法将问题分解为若干子问题递归求解后合并结果,如归并排序和快速排序,时间复杂度通常为O(n log n)。" 
#     },
#     {
#     "input": "动态规划算法的适用条件有哪些？",
#     "output": "动态规划要求问题具备最优子结构和重叠子问题特性，通过状态转移方程和记忆化存储（如背包问题）实现高效求解。" 
#     },
#     {
#     "input": "队列与栈的本质区别是什么？",
#     "output": "队列遵循先进先出(FIFO)原则,栈遵循后进先出(LIFO)原则,二者操作受限的线性结构特性决定其应用场景差异‌。" 
#     },
#     {
#     "input": "哈希表如何处理冲突？",
#     "output": "冲突处理方法包含开放地址法（线性探测、二次探测）和链地址法，前者通过探测新存储位置，后者在冲突位置建立链表存储。" 
#     },
#     {
#     "input": "B树与B+树的核心差异是什么？",
#     "output": "B树所有节点存储数据,B+树仅叶节点存数据且含顺序访问指针，后者更适用于数据库索引等磁盘密集型查询场景。" 
#     },
#     {
#     "input": "迪杰斯特拉算法的适用条件？",
#     "output": "要求图结构无负权边,采用贪心策略求解单源最短路径问题,时间复杂度为O(n²),可通过优先队列优化至O(m + n log n)。" 
#     },
#     {
#     "input": "红黑树的平衡规则有哪些？",
#     "output": "包含节点颜色交替、根叶节点黑、红节点子必黑、黑高一致四条规则,通过旋转和变色维护近似平衡,保证操作时间复杂度O(log n)‌。" 
#     },
#     {
#     "input": "AVL树与红黑树的性能对比?",
#     "output": "AVL树查询效率更高(严格平衡)，红黑树插入/删除效率更优(宽松平衡),内存数据库多用AVL,文件系统索引多用红黑树。" 
#     },
#     {
#     "input": "KMP算法核心思想是什么?",
#     "output": "通过构建部分匹配表(PMT)实现失败时模式串智能跳跃,避免主串回溯,将匹配时间复杂度从O(mn)降至O(m+n)。" 
#     },
#     {
#     "input": "布隆过滤器的误判率如何控制？",
#     "output": "误判率与哈希函数数量k、位数组大小m及元素数量n相关,根据公式m = -n ln p / (ln 2)^2 调整参数可实现精度控制。" 
#     },
#     {
#     "input": "快速排序的时间复杂度如何计算？", 
#     "output": "最优与平均时间复杂度为O(n log n),最差为O(n²)，取决于基准值选取策略。" 
#     }, 
#     { 
#     "input": "TCP与UDP的核心差异是什么?", 
#     "output": "TCP提供可靠传输和流量控制,UDP侧重低延迟传输,前者保证数据完整,后者允许丢包‌。" 
#     }, 
#     { 
#     "input": "数据库事务的ACID特性指什么?", 
#     "output": "原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)、持久性(Durability)‌。" 
#     },  
#     { 
#     "input": "二叉树前序遍历的非递归实现方式？", 
#     "output": "使用栈结构存储节点,按根→左→右顺序迭代处理,时间复杂度保持O(n)。" 
#     }, 
#     { 
#     "input": "动态规划解决问题的基本步骤？", 
#     "output": "定义状态→建立转移方程→确定初始条件→计算最优解→回溯路径。" 
#     }, 
#     { 
#     "input": "堆排序的稳定性如何？", 
#     "output": "不稳定排序算法，相同元素在堆调整时可能改变相对位置。" 
#     }, 
#     { 
#     "input": "数据库索引的优缺点分析？", 
#     "output": "加速查询但增加写入开销，需权衡查询频率与数据更新频率。" 
#     }, 
#     { 
#     "input": "冒泡排序优化方法有哪些？", 
#     "output": "添加标志位检测提前完成排序，或采用鸡尾酒排序双向遍历。" 
#     }, 
#     { 
#     "input": "RESTful API设计原则是什么?", 
#     "output": "无状态、统一接口、资源标识、缓存能力、分层系统。" 
#     }, 
#     { 
#     "input": "SQL注入攻击原理及防范措施?", 
#     "output": "通过输入恶意SQL片段,防范需使用参数化查询或ORM框架。" 
#     }, 
#     { 
#     "input": "如何保证多线程环境下的原子操作？", 
#     "output": "使用synchronized关键字、ReentrantLock锁或Atomic原子类。" 
#     }, 
#     { 
#     "input": "贪心算法的适用场景特征？", 
#     "output": "问题具有最优子结构且局部最优能推导全局最优解。" 
#     }, 
#     { 
#     "input": "数据库连接池的工作原理？", 
#     "output": "预先创建连接缓存，请求时分配空闲连接，用完回收复用。" 
#     }, 
#     { 
#     "input": "CAP理论中的三个特性指什么?", 
#     "output": "一致性(Consistency)、可用性(Availability)、分区容错性(Partition tolerance)。" 
#     }, 
#     { 
#     "input": "如何检测链表是否存在环？", 
#     "output": "快慢指针法：快指针每次两步，慢指针一步，相遇则有环。" 
#     }, 
#     { 
#     "input": "二叉搜索树的删除节点操作？", 
#     "output": "若节点有两个子节点，用右子树最小节点替换并递归删除。" 
#     }, 
#     { 
#     "input": "OSI七层模型包含哪些层级?", 
#     "output": "物理层→数据链路层→网络层→传输层→会话层→表示层→应用层。" 
#     }, 
#     { 
#     "input": "数据库范式的核心设计原则？", 
#     "output": "1NF属性原子性、2NF消除部分依赖、3NF消除传递依赖}。" 
#     }, 
#     { 
#     "input": "进程与线程的根本区别？", 
#     "output": "进程是资源分配单位,线程是CPU调度单位,线程共享进程资源。" 
#     }, 
#     { 
#     "input": "如何实现图像的边缘检测算法？", 
#     "output": "使用Sobel算子、Canny算法等卷积核进行梯度计算。" 
#     }, 
#     { 
#     "input": "对称加密与非对称加密对比？", 
#     "output": "对称加密速度快但密钥分发难，非对称安全性高但速度慢‌。" 
#     }, 
#     { 
#     "input": "数据库死锁的产生条件？", 
#     "output": "互斥、占有且等待、不可抢占、循环等待四条件同时成立。" 
#     }, 
#     { 
#     "input": "哈希算法的主要应用场景？", 
#     "output": "数据校验(MD5)、密码存储(加盐哈希)、快速查找(哈希表)。" 
#     }, 
#     { 
#     "input": "数据库回滚操作的实现原理？", 
#     "output": "利用事务日志undo log逆向执行已提交的变更操作。" 
#     },
#     {
#     "input": "图的深度优先搜索(DFS)的基本思想是什么？",
#     "output": "深度优先搜索(DFS)是一种遍历或搜索图或树数据结构的算法，它沿着树的深度遍历节点，直到达到叶节点或图中无更多节点可访问，然后回溯到上一个节点继续搜索。"
#     },
#     {
#     "input": "广度优先搜索(BFS)在图搜索中的应用？",
#     "output": "广度优先搜索(BFS)用于遍历或搜索图数据结构，从根节点开始，先访问所有相邻节点，再逐层向外扩展，常用于最短路径搜索、连通分量查找等场景。"
#     },
#     {
#     "input": "什么是图的连通分量？",
#     "output": "在无向图中，连通分量是极大连通子图，即子图内任意两顶点连通，且添加子图外任意顶点均不连通。在有向图中，分为强连通分量和弱连通分量。"
#     },
#     {
#     "input": "图的生成树是什么？",
#     "output": "生成树是包含图中所有顶点且边数最少的连通子图，对于无向图，有最小生成树(MST)概念,如Prim算法和Kruskal算法求解。"
#     },
#     {
#     "input": "Prim算法求解最小生成树的原理?",
#     "output": "Prim算法从某一顶点开始,逐步扩展生成树,每次选择连接生成树与未访问顶点中权重最小的边,直至所有顶点包含在内。"
#     },
#     {
#     "input": "Kruskal算法构建最小生成树的关键步骤?",
#     "output": "Kruskal算法将所有边按权重排序,从最小边开始，若加入边不形成环，则加入生成树，直至生成树包含所有顶点。"
#     },
#     {
#     "input": "什么是图的环检测？",
#     "output": "在图结构中，环检测是指识别图中是否存在至少一条边构成的闭合路径，常用于避免重复处理、检测无效路径等场景。"
#     },
#     {
#     "input": "图的割点与桥的定义？",
#     "output": "割点是指删除后导致图的连通分量数增加的顶点；桥（割边）是指删除后导致连通分量数增加的边。"
#     },
#     {
#     "input": "拓扑排序的适用场景及实现方法？",
#     "output": "拓扑排序适用于有向无环图(DAG)，将顶点线性排序，使得对于每条有向边(u, v),u在v之前。实现方法包括Kahn算法和DFS。"
#     },
#     {
#     "input": "关键路径法(CPM)在网络流分析中的作用？",
#     "output": "关键路径法(CPM)用于确定项目中最长的路径，即完成所有任务所需的最短时间，帮助识别项目瓶颈，优化资源分配。"
#     },
#     {
#     "input": "最短路径问题的常见求解算法？",
#     "output": "包括Dijkstra算法(适用于非负权图)、Bellman-Ford算法(允许负权边)和Floyd-Warshall算法(求所有顶点对间最短路径)。"
#     },
#     {
#     "input": "Dijkstra算法的核心思想是什么?",
#     "output": "Dijkstra算法采用贪心策略,每次从未访问顶点中选择距离源点最近的顶点加入最短路径树，更新相邻顶点距离，直至所有顶点访问完毕。"
#     },
#     {
#     "input": "Bellman-Ford算法处理负权边的优势是什么?",
#     "output": "Bellman-Ford算法通过n-1次松弛操作,能够正确处理包含负权边的图,且能检测负权回路。"
#     },
#     {
#     "input": "Floyd-Warshall算法的时间复杂度?",
#     "output": "Floyd-Warshall算法时间复杂度为O(n³)，用于计算所有顶点对之间的最短路径，适用于稠密图。"
#     },
#     {
#     "input": "A搜索算法的特点?",
#     "output": "A搜索算法结合启发式估计函数指导搜索方向,提高搜索效率，适用于求解路径规划、八数码问题等领域。"
#     },
#     {
#     "input": "什么是回溯算法？",
#     "output": "回溯算法是一种通过探索所有可能候选解并逐步构建解决方案的算法，若当前选择不可行，则回溯并尝试其他选择。"
#     },
#     {
#     "input": "回溯算法在八数码问题中的应用？",
#     "output": "八数码问题通过回溯算法尝试所有可能的滑块移动，利用目标状态与当前状态的差异评估可行性，直至找到解决方案。"
#     },
#     {
#     "input": "什么是分支限界法？",
#     "output": "分支限界法是一种在状态空间树或图中搜索问题的解的方法，通过限界函数剪枝，避免无效搜索，分为深度优先和广度优先两种策略。"
#     },
#     {
#     "input": "线性规划问题的求解方法？",
#     "output": "线性规划问题通过单纯形法、内点法等算法求解，寻找满足约束条件的线性目标函数最大值或最小值。"
#     },
#     {
#     "input": "单纯形法求解线性规划问题的基本步骤？",
#     "output": "单纯形法从可行域的一个顶点出发，通过迭代改善目标函数值，直至达到最优解或判定无界解。"
#     },
#     {
#     "input": "动态规划解决背包问题的步骤？",
#     "output": "定义状态数组dp,其中dp[i][j]表示前i个物品在总重量不超过j时的最大价值,通过状态转移方程递推求解。"
#     } ,
#     {
#     "input": "贪心算法在分数背包问题中的应用？",
#     "output": "分数背包问题允许物品分割，贪心策略选择单位重量价值最高的物品部分，直至背包容量用完。"
#     },
#     {
#     "input": "字符串匹配算法KMP中的next数组作用?",
#     "output": "KMP算法中的next数组用于记录部分匹配信息,实现模式串在匹配失败时的智能跳转，提高匹配效率。"
#     },
#     {
#     "input": "什么是后缀数组？",
#     "output": "后缀数组是对字符串所有后缀按字典序排序后的数组，常用于字符串匹配、重复子串查找等高效算法实现。"
#     },
#     {
#     "input": "后缀树在字符串处理中的应用？",
#     "output": "后缀树是一种紧凑的数据结构，表示字符串所有后缀的公共前缀，支持高效字符串匹配、最长公共前缀等查询。"
#     },
#     {
#     "input": "最大流问题的Ford-Fulkerson方法?",
#     "output": "Ford-Fulkerson方法通过寻找增广路径,不断增加流量，直至不存在增广路径，达到最大流。"
#     },
#     {
#     "input": "Edmonds-Karp算法求解最大流问题的核心思想?",
#     "output": "Edmonds-Karp算法是Ford-Fulkerson方法的一种实现,使用BFS寻找增广路径,时间复杂度为O(VE²)。"
#     },
#     {
#     "input": "最小费用流问题的求解算法？",
#     "output": "最小费用流问题通过Bellman-Ford算法或Dijkstra算法结合网络流算法(如Edmonds-Karp)求解,平衡流量与费用。"
#     },
#     {
#     "input": "什么是双端队列(deque)?",
#     "output": "双端队列(deque)是一种具有两个端点，允许在两端进行插入和删除操作的线性数据结构。"
#     },
#     {
#     "input": "跳表(Skip List)的基本结构？",
#     "output": "跳表是一种随机化的数据结构,通过多级索引加速查找操作,每层索引按一定概率包含下层部分元素,实现O(log n)时间复杂度。"
#     },
#     {
#     "input": "线段树(Segment Tree)的应用场景？",
#     "output": "线段树用于高效处理区间查询和更新问题，如区间求和、最大值、最小值等，广泛应用于一维空间上的动态查询场景。"
#     },
#     {
#     "input": "树状数组(Binary Indexed Tree)的用途？",
#     "output": "树状数组(又称Fenwick树)用于高效计算数组的前缀和,支持O(log n)时间复杂度的单点更新和前缀和查询。"
#     },
#     {
#     "input": "什么是Trie树(前缀树)?",
#     "output": "Trie树是一种用于高效存储和检索字符串集合的树形数据结构,特别适用于字符串前缀匹配、自动补全等应用。"
#     }
# ]